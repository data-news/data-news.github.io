<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>テトリス（スマホ最適化版）</title>
  <style>
    * {
      box-sizing: border-box;
      padding: 0;
      margin: 0;
    }

    html,
    body {
      height: 100%;
      overscroll-behavior: none;
    }

    body {
      /* iOS Safari のツールバーを除いた動的高さを優先して使う */
      min-height: 100dvh;
      background: radial-gradient(circle at top, #020617 0%, #000000 55%, #000000 100%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #f5f5f5;
      display: flex;
      justify-content: center;
      align-items: stretch;
      overflow: hidden;
    }

    .tetris-wrapper {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      max-width: 420px;
      height: 100%;
      max-height: 100dvh;
      /* セーフエリア分だけ上下に余白を足す（iPhone Safari 対策）*/
      padding-top: calc(8px + env(safe-area-inset-top, 0px));
      padding-bottom: calc(8px + env(safe-area-inset-bottom, 0px));
      padding-left: 8px;
      padding-right: 8px;
      margin: 0 auto;
      background: rgba(9, 9, 11, 0.96);
      box-shadow:
        0 24px 80px rgba(0, 0, 0, 0.9),
        0 0 0 1px rgba(148, 163, 184, 0.2);
    }

    .board-wrapper {
      position: relative;
      padding: 6px;
      border-radius: 14px;
      background: radial-gradient(circle at top, #1e293b 0%, #020617 65%);
      box-shadow:
        0 0 22px rgba(59, 130, 246, 0.5),
        inset 0 0 16px rgba(15, 23, 42, 0.9);
      flex: 1 1 auto;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 0;
      width: 100%;
    }

    #board {
      background: linear-gradient(180deg, #020617 0%, #020617 50%, #000000 100%);
      border-radius: 6px;
      box-shadow:
        0 0 0 2px rgba(37, 99, 235, 0.9),
        0 0 30px rgba(59, 130, 246, 0.9);
      display: block;
      touch-action: none;
    }

    .status-banner {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
    }

    .status-banner span {
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.7);
      backdrop-filter: blur(6px);
      font-size: 12px;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      text-align: center;
      line-height: 1.5;
    }
    .status-banner span.paused {
      color: #facc15;
    }
    .status-banner span.game-over {
      color: #f97373;
    }

    .hud {
      flex: 0 0 auto;
      width: 100%;
      max-width: 420px;
      padding: 4px 6px 2px;
      border-radius: 12px;
      background: radial-gradient(circle at top left, #111827 0%, #020617 55%);
      box-shadow:
        0 0 0 1px rgba(31, 41, 55, 0.9),
        0 10px 22px rgba(0, 0, 0, 0.85);
    }

    .hud-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .stats {
      display: flex;
      gap: 8px;
      font-size: 11px;
      flex-wrap: nowrap;
      white-space: nowrap;
    }
    .stat {
      display: flex;
      gap: 2px;
      align-items: baseline;
    }
    .stat-label {
      color: #9ca3af;
      font-size: 10px;
      letter-spacing: 0.08em;
      text-transform: uppercase;
    }
    .stat-value {
      color: #e5e7eb;
      font-variant-numeric: tabular-nums;
      font-size: 11px;
    }

    .mini-boards {
      display: flex;
      gap: 4px;
      justify-content: flex-end;
    }
    #holdCanvas,
    #nextCanvas {
      background: radial-gradient(circle at top, #020617 0%, #020617 60%, #000000 100%);
      border-radius: 6px;
      box-shadow:
        0 0 0 1px rgba(31, 41, 55, 0.9),
        inset 0 0 10px rgba(15, 23, 42, 0.9);
      display: block;
    }
    #holdCanvas {
      width: 70px;
      height: 50px;
    }
    #nextCanvas {
      width: 70px;
      height: 50px;
    }

    .controls-text {
      font-size: 10px;
      color: #e5e7eb;
      opacity: 0.9;
      text-align: left;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    .touch-buttons {
      display: flex;
      gap: 6px;
      margin-top: 2px;
    }
    .touch-buttons button,
    #restartBtn {
      flex: 1;
      padding: 6px 0;
      border-radius: 999px;
      border: none;
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      background: linear-gradient(135deg, #1d4ed8, #22c55e);
      color: #f9fafb;
      box-shadow:
        0 4px 10px rgba(37, 99, 235, 0.7),
        0 0 0 1px rgba(15, 23, 42, 0.9);
    }
    #holdBtn {
      flex: 1.1;
    }
    #pauseBtn {
      flex: 1;
    }
    #restartBtn {
      flex: 1.1;
      margin-top: 3px;
      background: linear-gradient(135deg, #3b82f6, #22c55e);
    }
    .touch-buttons button:active,
    #restartBtn:active {
      transform: translateY(1px);
      box-shadow:
        0 2px 6px rgba(37, 99, 235, 0.7),
        0 0 0 1px rgba(15, 23, 42, 0.9);
    }

    .garbage-warning {
      font-size: 9px;
      color: #fca5a5;
      margin-top: 1px;
      min-height: 1.2em;
      text-align: right;
      opacity: 0.9;
    }
  </style>
</head>
<body>
  <div class="tetris-wrapper">
    <div class="board-wrapper">
      <canvas id="board"></canvas>
      <div class="status-banner" id="statusBanner" style="display:none;">
        <span id="statusText"></span>
      </div>
    </div>

    <div class="hud">
      <div class="hud-row">
        <div class="stats">
          <div class="stat">
            <span class="stat-label">SCORE</span>
            <span class="stat-value" id="score">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">LINES</span>
            <span class="stat-value" id="lines">0</span>
          </div>
          <div class="stat">
            <span class="stat-label">LV</span>
            <span class="stat-value" id="level">1</span>
          </div>
        </div>
        <div class="mini-boards">
          <canvas id="holdCanvas" width="70" height="50"></canvas>
          <canvas id="nextCanvas" width="70" height="50"></canvas>
        </div>
      </div>

      <div class="hud-row" style="margin-bottom:3px;">
        <div class="controls-text">
          Tap: rotate / Swipe: move / Down flick: hard drop
        </div>
      </div>

      <div class="touch-buttons">
        <button id="holdBtn" type="button">HOLD</button>
        <button id="pauseBtn" type="button">PAUSE</button>
        <button id="restartBtn" type="button">RESTART</button>
      </div>
      <div class="garbage-warning" id="garbageInfo"></div>
    </div>
  </div>

  <script>
    const COLS = 10;
    const ROWS = 20;

    const BASE_BLOCK_SIZE = 30;
    let BLOCK_SIZE = BASE_BLOCK_SIZE;

    let HORIZONTAL_STEP = BLOCK_SIZE * 0.6;
    let HARD_DROP_DISTANCE = BLOCK_SIZE * 1.5;

    const canvas = document.getElementById("board");
    const ctx = canvas.getContext("2d");

    const holdCanvas = document.getElementById("holdCanvas");
    const holdCtx = holdCanvas.getContext("2d");
    const nextCanvas = document.getElementById("nextCanvas");
    const nextCtx = nextCanvas.getContext("2d");

    const scoreEl = document.getElementById("score");
    const linesEl = document.getElementById("lines");
    const levelEl = document.getElementById("level");
    const statusBanner = document.getElementById("statusBanner");
    const statusText = document.getElementById("statusText");
    const garbageInfo = document.getElementById("garbageInfo");
    const holdBtn = document.getElementById("holdBtn");
    const pauseBtn = document.getElementById("pauseBtn");
    const restartBtn = document.getElementById("restartBtn");

    const TETROMINOS = {
      I: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      O: [
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 0]
      ],
      T: [
        [0, 0, 0, 0],
        [1, 1, 1, 0],
        [0, 1, 0, 0],
        [0, 0, 0, 0]
      ],
      S: [
        [0, 0, 0, 0],
        [0, 1, 1, 0],
        [1, 1, 0, 0],
        [0, 0, 0, 0]
      ],
      Z: [
        [0, 0, 0, 0],
        [1, 1, 0, 0],
        [0, 1, 1, 0],
        [0, 0, 0, 0]
      ],
      J: [
        [0, 0, 0, 0],
        [1, 1, 1, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 0]
      ],
      L: [
        [0, 0, 0, 0],
        [1, 1, 1, 0],
        [1, 0, 0, 0],
        [0, 0, 0, 0]
      ]
    };

    const TYPES = Object.keys(TETROMINOS);

    const COLORS = {
      I: "#0ea5e9",
      O: "#eab308",
      T: "#a855f7",
      S: "#22c55e",
      Z: "#ef4444",
      J: "#3b82f6",
      L: "#f97316",
      G: "#4b5563"
    };
    const GHOST_COLOR = "rgba(148, 163, 184, 0.35)";

    const LINE_SCORES = {
      1: 100,
      2: 300,
      3: 500,
      4: 800
    };

    let board;
    let currentPiece = null;
    let nextQueue;
    let holdType = null;
    let holdUsedThisTurn = false;
    let score = 0;
    let lines = 0;
    let level = 1;
    let dropCounter = 0;
    let dropInterval = 1000;
    let lastTime = 0;
    let paused = false;
    let gameOver = false;
    let gameOverTime = 0;
    let gameStarted = false;

    let nextGarbageInMs = 20000;
    const MIN_GARBAGE_INTERVAL = 12000;
    const MAX_GARBAGE_INTERVAL = 26000;

    let lineClearEffects = [];
    let particles = [];
    let rippleEffects = [];
    let screenFlash = { timer: 0, max: 0 };
    let tetrisTextEffects = [];

    let touchInfo = {
      active: false,
      startX: 0,
      startY: 0,
      lastX: 0,
      lastY: 0,
      movedX: 0,
      movedY: 0,
      startTime: 0,
      gesture: "none"
    };
    let lastTapTime = 0;

    const TAP_MOVE_THRESHOLD = 6;
    const TAP_TOL = 6;
    const SOFT_DROP_THRESHOLD = 10;
    const HARD_DROP_TIME = 160;

    let lockedDuringTouch = false;

    function updateGeometry() {
      const wrapper = document.querySelector(".tetris-wrapper");
      const hud = document.querySelector(".hud");

      const visualHeight = window.innerHeight; // 動的ビューポート
      const hudHeight = hud.getBoundingClientRect().height || 150;

      const paddingTop = parseFloat(
        getComputedStyle(wrapper).paddingTop || "0"
      );
      const paddingBottom = parseFloat(
        getComputedStyle(wrapper).paddingBottom || "0"
      );

      const availableHeight = Math.max(
        visualHeight - hudHeight - paddingTop - paddingBottom - 8,
        120
      );

      const wrapperWidth = wrapper.getBoundingClientRect().width || window.innerWidth;
      const availableWidth = Math.min(wrapperWidth, window.innerWidth);

      const sizeByHeight = Math.floor(availableHeight / ROWS);
      const sizeByWidth = Math.floor(availableWidth / COLS);
      BLOCK_SIZE = Math.max(12, Math.min(sizeByHeight, sizeByWidth));

      canvas.width = COLS * BLOCK_SIZE;
      canvas.height = ROWS * BLOCK_SIZE;

      HORIZONTAL_STEP = BLOCK_SIZE * 0.6;
      HARD_DROP_DISTANCE = BLOCK_SIZE * 1.5;
    }

    window.addEventListener("resize", () => {
      updateGeometry();
    });

    function createBag() {
      const bag = [...TYPES];
      for (let i = bag.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [bag[i], bag[j]] = [bag[j], bag[i]];
      }
      return bag;
    }

    function createEmptyBoard() {
      return Array.from({ length: ROWS }, () => Array(COLS).fill(null));
    }

    function cloneMatrix(m) {
      return m.map(row => row.slice());
    }

    function resetCoreState() {
      board = createEmptyBoard();
      nextQueue = createBag();
      holdType = null;
      holdUsedThisTurn = false;
      score = 0;
      lines = 0;
      level = 1;
      dropCounter = 0;
      updateDropInterval();
      paused = false;
      gameOver = false;
      gameStarted = false;
      currentPiece = null;
      lineClearEffects = [];
      particles = [];
      rippleEffects = [];
      screenFlash = { timer: 0, max: 0 };
      tetrisTextEffects = [];
      resetGarbageTimer();
      updateUI();
      drawSidePanels();
    }

    function prepareNewGame() {
      resetCoreState();
      showStatus("TAP TO START", false);
    }

    function startGame() {
      resetCoreState();
      hideStatus();
      gameStarted = true;
      spawnPiece();
    }

    function updateDropInterval() {
      dropInterval = Math.max(120, 1000 - (level - 1) * 70);
    }

    function newPiece(type) {
      return {
        type,
        matrix: cloneMatrix(TETROMINOS[type]),
        x: 3,
        y: -1
      };
    }

    function spawnPiece() {
      if (nextQueue.length < 7) {
        nextQueue = nextQueue.concat(createBag());
      }
      const type = nextQueue.shift();
      currentPiece = newPiece(type);
      holdUsedThisTurn = false;

      if (collides(0, 0, currentPiece.matrix, currentPiece.x, currentPiece.y)) {
        gameOver = true;
        gameStarted = false;
        gameOverTime = performance.now();
        showGameOverStatus();
      }
      drawSidePanels();
    }

    function collides(offsetX, offsetY, matrix, px, py) {
      const xPos = px !== undefined ? px : currentPiece.x;
      const yPos = py !== undefined ? py : currentPiece.y;

      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          if (!matrix[y][x]) continue;
          const nx = xPos + x + offsetX;
          const ny = yPos + y + offsetY;
          if (ny < 0) continue;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (board[ny][nx]) return true;
        }
      }
      return false;
    }

    function mergePiece() {
      const { matrix, x, y, type } = currentPiece;
      for (let j = 0; j < 4; j++) {
        for (let i = 0; i < 4; i++) {
          if (!matrix[j][i]) continue;
          const ny = y + j;
          const nx = x + i;
          if (ny >= 0) board[ny][nx] = type;
        }
      }
    }

    function clearLines() {
      let fullRows = [];
      for (let y = 0; y < ROWS; y++) {
        let full = true;
        for (let x = 0; x < COLS; x++) {
          if (!board[y][x]) {
            full = false;
            break;
          }
        }
        if (full) fullRows.push(y);
      }
      if (fullRows.length === 0) return;

      const clearedCells = [];
      for (const y of fullRows) {
        for (let x = 0; x < COLS; x++) {
          if (board[y][x]) {
            clearedCells.push({ x, y, type: board[y][x] });
          }
        }
      }

      spawnParticlesForClearedCells(clearedCells);

      lineClearEffects.push({
        rows: fullRows.slice(),
        timer: 280,
        max: 280,
        isTetris: fullRows.length === 4
      });

      if (fullRows.length === 4) {
        triggerScreenFlash(520);
        rippleEffects.push({
          x: (COLS * BLOCK_SIZE) / 2,
          y: (ROWS * BLOCK_SIZE) / 2,
          radius: 0,
          speed: 0.7 * BLOCK_SIZE,
          timer: 600,
          max: 600
        });
        tetrisTextEffects.push({
          text: "TETRIS!",
          timer: 900,
          max: 900
        });
      } else {
        triggerScreenFlash(220);
      }

      lines += fullRows.length;
      const base = LINE_SCORES[fullRows.length] || 0;
      score += base * level;
      const newLevel = Math.floor(lines / 10) + 1;
      if (newLevel !== level) {
        level = newLevel;
        updateDropInterval();
      }

      const sorted = fullRows.slice().sort((a, b) => b - a);
      for (const y of sorted) {
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(null));
      }
    }

    function triggerScreenFlash(duration) {
      screenFlash.timer = duration;
      screenFlash.max = duration;
    }

    function spawnParticlesForClearedCells(cells) {
      const centerX = COLS / 2;
      const centerY = ROWS / 2;

      for (const cell of cells) {
        const baseColor = COLORS[cell.type] || "#e5e7eb";
        const px = cell.x + 0.5;
        const py = cell.y + 0.5;
        const count = 4;

        for (let i = 0; i < count; i++) {
          const isInward = Math.random() < 0.5;
          let vx, vy;

          if (isInward) {
            let dx = centerX - px;
            let dy = centerY - py;
            const len = Math.sqrt(dx * dx + dy * dy) || 1;
            dx /= len;
            dy /= len;
            const speed = 0.006 + Math.random() * 0.008;
            vx = dx * speed;
            vy = dy * speed;
          } else {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.01 + Math.random() * 0.02;
            vx = Math.cos(angle) * speed;
            vy = Math.sin(angle) * speed;
          }

          const life = 400 + Math.random() * 300;
          particles.push({
            x: px,
            y: py,
            vx,
            vy,
            life,
            maxLife: life,
            color: baseColor
          });
        }
      }
    }

    function rotateMatrixCW(matrix) {
      const result = Array.from({ length: 4 }, () => Array(4).fill(0));
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          result[x][3 - y] = matrix[y][x];
        }
      }
      return result;
    }

    function rotateMatrixCCW(matrix) {
      const result = Array.from({ length: 4 }, () => Array(4).fill(0));
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          result[3 - x][y] = matrix[y][x];
        }
      }
      return result;
    }

    function tryRotate(clockwise = true) {
      if (!currentPiece) return;
      const original = currentPiece.matrix;
      const rotated = clockwise ? rotateMatrixCW(original) : rotateMatrixCCW(original);

      const offsets = [
        { x: 0, y: 0 },
        { x: -1, y: 0 },
        { x: 1, y: 0 },
        { x: -2, y: 0 },
        { x: 2, y: 0 },
        { x: 0, y: -1 }
      ];

      for (const off of offsets) {
        if (!collides(off.x, off.y, rotated)) {
          currentPiece.matrix = rotated;
          currentPiece.x += off.x;
          currentPiece.y += off.y;
          return;
        }
      }
    }

    function hardDrop() {
      if (!currentPiece || gameOver || paused || !gameStarted) return;
      let dropDistance = 0;
      while (!collides(0, 1, currentPiece.matrix)) {
        currentPiece.y++;
        dropDistance++;
      }
      if (dropDistance > 0) {
        score += dropDistance * 2;
      }
      lockPiece();
    }

    function softDrop(fromUser = false) {
      if (!currentPiece || gameOver || !gameStarted) return;
      if (!collides(0, 1, currentPiece.matrix)) {
        currentPiece.y++;
        if (fromUser) {
          score += 1;
        }
      } else {
        lockPiece();
      }
    }

    function lockPiece() {
      mergePiece();
      clearLines();           // ★ ロックと同じタイミングで必ず行消去
      drawSidePanels();       // ★ スコアなどもこのタイミングで更新
      if (touchInfo.active) {
        lockedDuringTouch = true;
      }
      spawnPiece();
    }

    function holdPiece() {
      if (!currentPiece || holdUsedThisTurn || gameOver || paused || !gameStarted) return;
      const type = currentPiece.type;
      if (holdType === null) {
        holdType = type;
        spawnPiece();
      } else {
        const temp = holdType;
        holdType = type;
        currentPiece = newPiece(temp);
      }
      holdUsedThisTurn = true;
      drawSidePanels();
    }

    function updateUI() {
      scoreEl.textContent = score;
      linesEl.textContent = lines;
      levelEl.textContent = level;
    }

    function showStatus(text, isGameOver = false) {
      statusBanner.style.display = "flex";
      statusText.className = isGameOver ? "game-over" : "paused";
      statusText.innerHTML = text;
    }

    function showGameOverStatus() {
      const msg =
        "GAME&nbsp;OVER<br>" +
        "SCORE " + score + " / LINES " + lines + " / LV " + level +
        "<br>WAIT 5 SEC";
      showStatus(msg, true);
    }

    function hideStatus() {
      statusBanner.style.display = "none";
      statusText.textContent = "";
      statusText.className = "";
    }

    function togglePause() {
      if (!gameStarted || gameOver) return;
      paused = !paused;
      if (paused) {
        showStatus("PAUSED", false);
      } else {
        hideStatus();
      }
    }

    function canRestartFromGameOver() {
      if (!gameOver) return true;
      const elapsed = performance.now() - gameOverTime;
      return elapsed >= 5000;
    }

    function computeGhostY() {
      if (!currentPiece) return 0;
      let y = currentPiece.y;
      while (!collides(0, 1, currentPiece.matrix, currentPiece.x, y)) {
        y++;
      }
      return y;
    }

    function drawBlock(ctx2, x, y, size, color, border = true) {
      ctx2.fillStyle = color;
      ctx2.fillRect(x * size, y * size, size, size);
      if (border) {
        ctx2.lineWidth = 1;
        ctx2.strokeStyle = "rgba(15,23,42,0.9)";
        ctx2.strokeRect(
          x * size + 0.5,
          y * size + 0.5,
          size - 1,
          size - 1
        );
      }
    }

    function drawBoard() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.fillStyle = "#020617";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = "rgba(148,163,184,0.18)";
      ctx.lineWidth = 1;
      for (let x = 0; x <= COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * BLOCK_SIZE + 0.5, 0);
        ctx.lineTo(x * BLOCK_SIZE + 0.5, ROWS * BLOCK_SIZE);
        ctx.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * BLOCK_SIZE + 0.5);
        ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE + 0.5);
        ctx.stroke();
      }

      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const type = board[y][x];
          if (type) drawBlock(ctx, x, y, BLOCK_SIZE, COLORS[type]);
        }
      }

      if (currentPiece) {
        const ghostY = computeGhostY();
        const { matrix, x, y, type } = currentPiece;
        for (let j = 0; j < 4; j++) {
          for (let i = 0; i < 4; i++) {
            if (!matrix[j][i]) continue;
            const gx = x + i;
            const gy = ghostY + j;
            if (gy < 0) continue;
            ctx.fillStyle = GHOST_COLOR;
            ctx.fillRect(
              gx * BLOCK_SIZE + 4,
              gy * BLOCK_SIZE + 4,
              BLOCK_SIZE - 8,
              BLOCK_SIZE - 8
            );
          }
        }

        for (let j = 0; j < 4; j++) {
          for (let i = 0; i < 4; i++) {
            if (!matrix[j][i]) continue;
            const nx = x + i;
            const ny = y + j;
            if (ny < 0) continue;
            drawBlock(ctx, nx, ny, BLOCK_SIZE, COLORS[type]);
          }
        }
      }

      drawLineClearEffects();
      drawParticles();
      drawRipples();
      drawScreenFlash();
      drawTetrisText();
      drawGarbageWarningVisual();
    }

    function drawLineClearEffects() {
      for (const eff of lineClearEffects) {
        const alpha = Math.max(eff.timer / eff.max, 0);
        ctx.save();
        ctx.globalCompositeOperation = "screen";
        const baseAlpha = eff.isTetris ? 0.55 : 0.35;
        ctx.fillStyle = `rgba(255,255,255,${baseAlpha * alpha})`;
        for (const row of eff.rows) {
          ctx.fillRect(
            0,
            row * BLOCK_SIZE,
            COLS * BLOCK_SIZE,
            BLOCK_SIZE
          );
        }
        ctx.restore();
      }
    }

    function drawParticles() {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (const p of particles) {
        const lifeRatio = p.life / p.maxLife;
        const size = 3 + 3 * lifeRatio;
        const alpha = 0.25 + 0.55 * lifeRatio;
        ctx.fillStyle = hexToRgba(p.color, alpha);
        ctx.fillRect(
          p.x * BLOCK_SIZE - size / 2,
          p.y * BLOCK_SIZE - size / 2,
          size,
          size
        );
      }
      ctx.restore();
    }

    function drawRipples() {
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      for (const r of rippleEffects) {
        const alpha = Math.max(r.timer / r.max, 0);
        ctx.beginPath();
        ctx.arc(r.x, r.y, r.radius, 0, Math.PI * 2);
        ctx.lineWidth = 3;
        ctx.strokeStyle = `rgba(56,189,248,${0.45 * alpha})`;
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawScreenFlash() {
      if (screenFlash.timer <= 0) return;
      const ratio = screenFlash.timer / screenFlash.max;
      const alpha = 0.7 * ratio;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = `rgba(255,255,255,${alpha})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
    }

    function drawTetrisText() {
      ctx.save();
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      for (const t of tetrisTextEffects) {
        const ratio = t.timer / t.max;
        const alpha = Math.min(1, 1.1 * ratio);
        const yOffset = (1 - ratio) * 40;
        ctx.font = "bold 32px system-ui, sans-serif";
        ctx.fillStyle = `rgba(248,250,252,${alpha})`;
        ctx.strokeStyle = `rgba(59,130,246,${alpha})`;
        ctx.lineWidth = 2;
        const cx = canvas.width / 2;
        const cy = canvas.height / 2 + yOffset;
        ctx.fillText(t.text, cx, cy);
        ctx.strokeText(t.text, cx, cy);
      }
      ctx.restore();
    }

    function drawGarbageWarningVisual() {
      const threshold = 3500;
      if (nextGarbageInMs > threshold) return;
      const ratio = 1 - nextGarbageInMs / threshold;
      const alpha = 0.15 + 0.25 * ratio;
      ctx.save();
      ctx.globalCompositeOperation = "screen";
      ctx.fillStyle = `rgba(248,113,113,${alpha})`;
      ctx.fillRect(
        0,
        (ROWS - 2) * BLOCK_SIZE,
        COLS * BLOCK_SIZE,
        2 * BLOCK_SIZE
      );
      ctx.restore();
    }

    function hexToRgba(hex, alpha) {
      let c = hex.replace("#", "");
      if (c.length === 3) {
        c = c[0] + c[0] + c[1] + c[1] + c[2] + c[2];
      }
      const num = parseInt(c, 16);
      const r = (num >> 16) & 255;
      const g = (num >> 8) & 255;
      const b = num & 255;
      return `rgba(${r},${g},${b},${alpha})`;
    }

    function drawMiniPiece(ctx2, type, canvasWidth, canvasHeight) {
      ctx2.clearRect(0, 0, canvasWidth, canvasHeight);
      if (!type) return;
      const matrix = TETROMINOS[type];
      const size = 16;

      let minX = 4, maxX = -1, minY = 4, maxY = -1;
      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          if (matrix[y][x]) {
            if (x < minX) minX = x;
            if (x > maxX) maxX = x;
            if (y < minY) minY = y;
            if (y > maxY) maxY = y;
          }
        }
      }
      const w = maxX - minX + 1;
      const h = maxY - minY + 1;
      const offsetX = Math.floor((canvasWidth / size - w) / 2) - minX;
      const offsetY = Math.floor((canvasHeight / size - h) / 2) - minY;

      for (let y = 0; y < 4; y++) {
        for (let x = 0; x < 4; x++) {
          if (!matrix[y][x]) continue;
          drawBlock(ctx2, x + offsetX, y + offsetY, size, COLORS[type]);
        }
      }
    }

    function drawHold() {
      drawMiniPiece(
        holdCtx,
        holdType,
        holdCanvas.width,
        holdCanvas.height
      );
    }

    function drawNext() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      const previewCount = 3;
      const size = 14;
      const verticalGap = 2;

      for (let index = 0; index < Math.min(previewCount, nextQueue.length); index++) {
        const type = nextQueue[index];
        const matrix = TETROMINOS[type];

        let minX = 4, maxX = -1, minY = 4, maxY = -1;
        for (let y = 0; y < 4; y++) {
          for (let x = 0; x < 4; x++) {
            if (matrix[y][x]) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          }
        }
        const w = maxX - minX + 1;
        const h = maxY - minY + 1;
        const offsetX = Math.floor((nextCanvas.width / size - w) / 2) - minX;
        const areaHeight = 4 * size + verticalGap;
        const baseY = index * areaHeight;
        const offsetY = Math.floor((4 - h) / 2) - minY;

        for (let y = 0; y < 4; y++) {
          for (let x = 0; x < 4; x++) {
            if (!matrix[y][x]) continue;
            const drawY = baseY / size + y + offsetY;
            drawBlock(nextCtx, x + offsetX, drawY, size, COLORS[type]);
          }
        }
      }
    }

    function drawSidePanels() {
      updateUI();
      drawHold();
      drawNext();
      updateGarbageInfo();
    }

    function updateGarbageInfo() {
      const sec = (nextGarbageInMs / 1000).toFixed(1);
      garbageInfo.textContent = `Garbage in: ${sec}s`;
    }

    function addGarbageLines(count) {
      for (let c = 0; c < count; c++) {
        const line = Array(COLS).fill("G");
        const holeX = Math.floor(Math.random() * COLS);
        line[holeX] = null;
        board.shift();
        board.push(line);
      }
    }

    function resetGarbageTimer() {
      nextGarbageInMs =
        MIN_GARBAGE_INTERVAL +
        Math.random() * (MAX_GARBAGE_INTERVAL - MIN_GARBAGE_INTERVAL);
    }

    function updateEffects(delta) {
      lineClearEffects.forEach(e => { e.timer -= delta; });
      lineClearEffects = lineClearEffects.filter(e => e.timer > 0);

      particles.forEach(p => {
        p.life -= delta;
        p.x += p.vx * delta;
        p.y += p.vy * delta;
      });
      particles = particles.filter(p => p.life > 0);

      rippleEffects.forEach(r => {
        r.timer -= delta;
        r.radius += r.speed * (delta / 16);
      });
      rippleEffects = rippleEffects.filter(r => r.timer > 0);

      if (screenFlash.timer > 0) {
        screenFlash.timer -= delta;
        if (screenFlash.timer < 0) screenFlash.timer = 0;
      }

      tetrisTextEffects.forEach(t => { t.timer -= delta; });
      tetrisTextEffects = tetrisTextEffects.filter(t => t.timer > 0);

      if (gameStarted && !gameOver && !paused) {
        nextGarbageInMs -= delta;
        if (nextGarbageInMs <= 0) {
          addGarbageLines(1);
          resetGarbageTimer();
        }
      }
      updateGarbageInfo();
    }

    function update(time = 0) {
      const delta = time - lastTime;
      lastTime = time;

      if (gameStarted && !paused && !gameOver) {
        dropCounter += delta;
        if (dropCounter > dropInterval) {
          softDrop(false);
          dropCounter = 0;
        }
      }

      updateEffects(delta);
      drawBoard();
      requestAnimationFrame(update);
    }

    document.addEventListener("keydown", e => {
      if (["ArrowLeft", "ArrowRight", "ArrowDown", "ArrowUp", "Space"].includes(e.code)) {
        e.preventDefault();
      }

      if (!currentPiece || !gameStarted) {
        if (gameOver) {
          if (!canRestartFromGameOver()) return;
          if (e.code === "Space" || e.code === "Enter") {
            startGame();
          }
        }
        return;
      }
      if (paused && e.code !== "KeyP") return;
      if (gameOver) return;

      switch (e.code) {
        case "ArrowLeft":
          if (!collides(-1, 0, currentPiece.matrix)) currentPiece.x--;
          break;
        case "ArrowRight":
          if (!collides(1, 0, currentPiece.matrix)) currentPiece.x++;
          break;
        case "ArrowDown":
          softDrop(true);
          dropCounter = 0;
          break;
        case "ArrowUp":
        case "KeyX":
          tryRotate(true);
          break;
        case "KeyZ":
          tryRotate(false);
          break;
        case "Space":
          hardDrop();
          dropCounter = 0;
          break;
        case "ShiftLeft":
        case "ShiftRight":
          holdPiece();
          break;
        case "KeyP":
          togglePause();
          break;
      }
    });

    canvas.addEventListener("touchstart", e => {
      e.preventDefault();
      if (e.touches.length > 1) return;
      const touch = e.touches[0];
      touchInfo.active = true;
      touchInfo.startX = touch.clientX;
      touchInfo.startY = touch.clientY;
      touchInfo.lastX = touch.clientX;
      touchInfo.lastY = touch.clientY;
      touchInfo.movedX = 0;
      touchInfo.movedY = 0;
      touchInfo.startTime = e.timeStamp;
      touchInfo.gesture = "none";
      lockedDuringTouch = false;
    }, { passive: false });

    canvas.addEventListener("touchmove", e => {
      e.preventDefault();
      if (!touchInfo.active || !gameStarted || paused || gameOver || !currentPiece) return;
      const touch = e.touches[0];
      const dx = touch.clientX - touchInfo.lastX;
      const dy = touch.clientY - touchInfo.lastY;

      touchInfo.lastX = touch.clientX;
      touchInfo.lastY = touch.clientY;
      touchInfo.movedX += dx;
      touchInfo.movedY += dy;

      const totalDx = touch.clientX - touchInfo.startX;
      const totalDy = touch.clientY - touchInfo.startY;

      if (touchInfo.gesture === "none") {
        const absDx = Math.abs(totalDx);
        const absDy = Math.abs(totalDy);
        if (absDx > absDy * 1.2 && absDx > TAP_MOVE_THRESHOLD) {
          touchInfo.gesture = "horizontal";
        } else if (absDy > absDx * 1.2 && absDy > TAP_MOVE_THRESHOLD) {
          touchInfo.gesture = "vertical";
        }
      }

      if (touchInfo.gesture === "horizontal") {
        const stepX = Math.trunc(touchInfo.movedX / HORIZONTAL_STEP);
        if (stepX !== 0) {
          const dir = Math.sign(stepX);
          for (let i = 0; i < Math.abs(stepX); i++) {
            if (!collides(dir, 0, currentPiece.matrix)) {
              currentPiece.x += dir;
            } else {
              break;
            }
          }
          touchInfo.movedX -= stepX * HORIZONTAL_STEP;
        }
      } else if (touchInfo.gesture === "vertical") {
        if (dy > SOFT_DROP_THRESHOLD) {
          softDrop(true);
          dropCounter = 0;
        }
      }
    }, { passive: false });

    canvas.addEventListener("touchend", e => {
      e.preventDefault();
      if (!touchInfo.active) return;
      const touch = e.changedTouches[0];
      const endTime = e.timeStamp;
      const totalDx = touch.clientX - touchInfo.startX;
      const totalDy = touch.clientY - touchInfo.startY;
      const absDx = Math.abs(totalDx);
      const absDy = Math.abs(totalDy);
      const dt = endTime - touchInfo.startTime;

      const wasGesture = touchInfo.gesture;
      touchInfo.active = false;

      if (lockedDuringTouch) {
        lockedDuringTouch = false;
        return;
      }

      if (!gameStarted || gameOver) {
        if (gameOver && !canRestartFromGameOver()) return;
        startGame();
        return;
      }
      if (!currentPiece || paused) return;

      if (wasGesture === "none" && absDx < TAP_TOL && absDy < TAP_TOL) {
        const now = endTime;
        if (now - lastTapTime < 250) {
          tryRotate(false);
          lastTapTime = 0;
        } else {
          tryRotate(true);
          lastTapTime = now;
        }
      } else {
        if ((wasGesture === "vertical" || absDy > absDx) &&
            totalDy > HARD_DROP_DISTANCE && dt < HARD_DROP_TIME) {
          hardDrop();
          dropCounter = 0;
        }
      }
    }, { passive: false });

    canvas.addEventListener("click", () => {
      if (!gameStarted || gameOver) {
        if (gameOver && !canRestartFromGameOver()) return;
        startGame();
      }
    });

    holdBtn.addEventListener("click", () => {
      holdPiece();
    });

    pauseBtn.addEventListener("click", () => {
      togglePause();
    });

    restartBtn.addEventListener("click", () => {
      if (gameOver && !canRestartFromGameOver()) return;
      startGame();
    });

    function initAndStart() {
      updateGeometry();
      prepareNewGame();
      requestAnimationFrame(update);
    }

    initAndStart();
  </script>
</body>
</html>
